---
title: sample.bin
date: 2025-07-15 15:08:56 +0700
categories: [Malware Analysis, Reverse Engineering]
tags: [autoit, backdoor, wacatac, unpack, memory-dump]
description: Phân tích bước đầu mẫu AutoIt `sample.bin` (ráp dạng Backdoor/Trojan.Agent.Wacatac) decompile AutoIt, bypass anti-debug, quan sát VirtualAlloc + dump vùng nhớ để tiếp tục giải mã.
---

# 🔎 Phân tích mẫu `sample.bin` (AutoIt — Trojan.Agent / Backdoor) — tiếp tục

**File**: `sample.bin`
**File type**: executable (AutoIt)
**MD5**: `66f33597cbf097345c51891ab951b641`
**VirusTotal**: Backdoor / Trojan.Agent.Wacatac

![VT detection](/resources/Sample-bin/Pasted%20image%2020251001150856.png)

---

## 🧊 Tóm tắt bước đã làm (từ phần bạn cung cấp)

- Xác định: **AutoIt packed** (exe chứa script trong .rdata / .rsrc).
  ![ExeinfoPE](/resources/Sample-bin/Pasted%20image%2020251001151054.png)

- PeStudio liệt kê nhiều cảnh báo level 1 (embedded AutoIt script lớn trong .rdata/.rsrc, imports liên quan mạng/WMIC/Psapi/IpHelper...).
  ![PeStudio indicators](/resources/Sample-bin/Pasted%20image%2020251001152108.png)

- Trong resources có `RCData` chứa script AutoIt → dùng `exe2aut` decompile ra `sample_.au3`. Mở bằng Notepad++ thấy script dài, phần mã chính được **mã hoá/ghép chuỗi** bởi hàm `mdfzjnyhbr()` liên tục nối `$j` với chính nó.
  ![Resource rcdata / script](/resources/Sample-bin/Pasted%20image%2020251001152224.png)
  ![Script snippet](/resources/Sample-bin/Pasted%20image%2020251001152806.png)
  ![Obfuscated concatenation function](/resources/Sample-bin/Pasted%20image%2020251001153616.png)

- Trong phân tích tĩnh/IDA: phát hiện kiểm tra anti-debug `IsDebuggerPresent` tại `sub_403b3a` (offset file: 0x2F7A). Khi chạy, hàm trả 1 → chương trình thoát. Ta đã đặt breakpoint và **sửa giá trị trả về** thành 0 để tiếp tục phân tích.
  ![IsDebuggerPresent hit](/resources/Sample-bin/Pasted%20image%2020251001155457.png)
  ![Breakpoint & patch in x32dbg](/resources/Sample-bin/Pasted%20image%20202510011561251.png)

- Quan sát hành vi giải mã động: chương trình gọi `VirtualAlloc` / `VirtualAllocEx` nhiều lần và cấp vùng nhớ có quyền **ERW** (Execute + Read + Write). Hai vùng đáng chú ý được cấp:

  - `Address = 0x01170000` — Size ≈ 0x35000 — PROT = ERW
  - `Address = 0x011C0000` — Size ≈ 0x35000 — PROT = ERW

- Dump vùng nhớ thứ hai (0x011C0000) bằng ProcessHacker (vì vùng 1 chỉ chứa data tạm) và lưu ra file dump để phân tích tiếp.
  ![Process Hacker dump](/resources/Sample-bin/Pasted%20image%2020251001164403.png)

> Bạn tạm dừng ở đây vì bước deobfuscate/decode script từ vùng nhớ sẽ rất tốn thời gian — tôi sẽ tiếp tục phần này trong tài liệu dưới, nêu các bước tiếp theo và cách tiếp cận chi tiết.

---

## 🔧 Phần tiếp theo (hướng dẫn chi tiết — cách làm để hoàn tất phân tích)

Dưới đây là các bước tiếp theo nên làm (có thể bạn đã/perhaps muốn làm tiếp):

### 1) Chuẩn bị các artifact dump
- Đặt tên file dump rõ ràng khi dump vùng nhớ (ví dụ):
  - `sample_mem_01170000.bin`
  - `sample_mem_011C0000.bin`
- Lưu kèm metadata: PID, timestamp, base address, size, tool (ProcessHacker/WinDbg).

### 2) Phân tích dump (statical / strings / x86 disasm)
- Chạy `strings -a -el` trên dump để tìm chuỗi UTF-16/ASCII có ý nghĩa (URL, domain, IP, API, javascript/html templates).
- Dùng `binwalk` / `foremost` / `scalpel` để dò xem trong dump có file nhúng (PE, ZIP, HTML, PNG...)
- Load dump vào IDA / Ghidra và tìm các entry code (địa chỉ chứa nhiều opcodes tương tự mã máy). Nếu dump chứa shellcode, dùng Linear Disassembler để disasm bắt đầu từ offsets có nhiều `0xE8/0xFF` (call/jmp patterns).

### 3) Giải mã chuỗi ghép trong AutoIt
- Mở `sample_.au3` (decompiled script). Tìm hàm `mdfzjnyhbr()` — đây là "string builder" hoặc unpacker.
- Cách tiếp cận:
  1. Thực hiện **đoạn script trong môi trường AutoIt** an toàn (sandbox) và log biến `$j` sau mỗi lần nối để xem kết quả từng bước (chú ý: script có thể thực thi code nguy hiểm — chỉ chạy trên VM cô lập không kết nối mạng).
  2. Nếu không muốn chạy, **dịch ngược thuật toán nối**: chuyển hàm deobfuscator sang Python và chạy offline trên dump hoặc trên nội dung RCData. (Thường AutoIt obfuscators dùng XOR/ROT/BASE64/concat patterns — có thể dịch được).
  3. Nếu chuỗi ghép rất dài, kiểm tra xem có pattern mã hoá block (ví dụ mỗi lần nối thực chất là decrypt block bằng key) — tách block và thử các phép toán XOR/xor key bruteforce nhỏ.

### 4) Tìm C2 / IOC trong payload đã giải mã
- Sau khi giải mã nội dung script hoặc shellcode, search các pattern sau: `http://`, `https://`, `GET `, `POST `, IP addresses, domain names, registry keys, filenames, mutex names.
- Ghi lại IOC: domains, IPs, drop file names, registry keys, autorun entries, mutexes.

### 5) Nếu dump chứa PE (giai đoạn 2 payload)
- If you find a PE, try to reconstruct and load into IDA for static analysis. Nếu PE bị packed, thử unpack bằng UPX / manual unpacking (Scylla) hoặc bằng cách emulation.

### 6) Dynamic tracing (nếu cần)
- Đặt breakpoint vào địa chỉ virtualAlloc return → theo dõi write into the allocated regions (WriteProcessMemory/WriteFile).
- Theo dõi CreateRemoteThread / VirtualProtect calls — đây thường là dấu hiệu shellcode được viết rồi chuyển sang execute.

### 7) Tạo indicators & YARA
- Khi tìm được strings/doms/IOCs, tạo YARA rules và signatures để quét tập mẫu lớn hơn.

---

## 🧾 Những phát hiện tạm thời & kết luận

- **Loại:** AutoIt executable chứa script lớn trong resources → AutoIt-based backdoor/downloader.
- **Anti-analysis:** Kiểm tra debugger (`IsDebuggerPresent`) → program thoát nếu bị debug; bạn đã bypass bằng cách sửa trả về 0.
- **Runtime unpack:** Dùng `VirtualAlloc` để cấp vùng ERW, khả năng giải mã code/strings vào đó → cho thấy động cơ load-and-execute (shellcode hoặc mã AutoIt đã decode).
- **Dump vùng nhớ 0x011C0000** đã được tạo — đây là artifact quan trọng để tiếp tục deobfuscate.
- **Tiếp tục cần làm:** giải mã hàm nối (mdfzjnyhbr), phân tích dump (tìm C2/strings) và xem payload thứ cấp.

---

## 📌 IOC tạm thời (chưa đầy đủ — cập nhật khi giải mã xong)

| Loại              | Giá trị                                                      |
| ----------------- | ------------------------------------------------------------ |
| File name         | `sample.bin`                                                 |
| MD5               | `66f33597cbf097345c51891ab951b641`                           |
| Type              | AutoIt executable (embedded script)                          |
| Notable functions | `mdfzjnyhbr()` (obfuscator / string builder)                 |
| Anti-debug        | `IsDebuggerPresent` hit at `sub_403b3a` (file offset 0x2F7A) |
| Memory regions    | Alloc ERW at `0x01170000`, `0x011C0000` (dump second region) |

> **Chú ý:** Những IOC liên quan tới domain/IP chưa rõ ràng — phải từ nội dung đã giải mã.

---

## 🛡️ Khuyến nghị khẩn cấp (đối với SOC / IR)

1. Nếu phát hiện file này trong tổ chức: **Cách ly máy**, thu thập memory dump & network capture.
2. Block khả nghi: outbound bất thường từ host tới domain / IP mới nổi (sau khi có thông tin domain sẽ cập nhật).
3. Quét hệ thống tìm các file AutoIt tương tự (exe chứa `.rdata`/.rsrc` lớn), kiểm tra Run keys / scheduled tasks.
4. Nếu đã có dump vùng nhớ, tiến hành static analysis offline để lấy C2 và các chỉ thị (commands).
5. Nếu không có kỹ năng unpack/deobfuscate — gửi artifact lên đội phản ứng chuyên sâu hoặc malware lab.

---

## 🔁 Gợi ý công cụ & lệnh hay dùng

- `exe2aut` → decompile AutoIt executable → `sample_.au3`
- `strings -a -el sample_mem_011C0000.bin`
- `binwalk` / `foremost` / `rabin2` / `radare2` (quick carving)
- IDA Pro / Ghidra cho disasm dump
- x32dbg / WinDbg / ProcessHacker / ProcMon / Regshot cho dynamic tracing
- Python (script deobfuscator) để emulate hàm nối `$j = $j & "...";` và reconstruct strings

---

> {: .prompt-info}
> **Mẹo ghi nhớ**
> Hình dung quy trình như sau:
> - **AutoIt exe** giống một cái “hộp quà” có _thư mục bí mật_ (resources .rdata/.rsrc).
> - **exe2aut** là cái kìm để mở hộp ra (lấy `sample_.au3`).
> - **Hàm mdfzjnyhbr()** là cuộn băng keo: nó dán từng mảnh chữ vào nhau để che nội dung thực. Muốn tách ra thì hãy cắt từng mảnh (dump vùng nhớ hoặc chạy đoạn deobfuscator offline) — ghép lại ta sẽ thấy bức tranh (C2 / lệnh).
> - **VirtualAlloc → vùng ERW** giống cái bàn thao tác mà malware dùng để “khâu” mã đã giải mã và bật nó chạy. Dump cái bàn này để lấy thành phần thực thi.

---

### Kết luận ngắn
Bạn đã tới đúng chỗ: bypass anti-debug, tìm ra nơi malware giải mã vào bộ nhớ và dump vùng chứa payload. Bước tiếp theo là **phân tích dump** và **dịch hàm nối trong `sample_.au3`** để lộ IOC / C2. Nếu bạn muốn, tôi sẽ:

- (A) Viết script Python mô phỏng hàm `mdfzjnyhbr()` để giải mã chuỗi từ `sample_.au3` (nếu bạn paste đoạn hàm đó), **hoặc**
- (B) Phân tích file dump `sample_mem_011C0000.bin` (nếu bạn upload) và tóm tắt kết quả (chuỗi, PE embedded, C2).

Bạn chọn A hay B — tôi sẽ bắt tay làm luôn phần phân tích tiếp theo dựa trên lựa chọn đó và dữ liệu bạn cung cấp.
